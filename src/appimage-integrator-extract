#!/bin/bash



#     _               ___
#    / \   _ __  _ __|_ _|_ __ ___   __ _  __ _  ___
#   / _ \ | '_ \| '_ \| || '_ ` _ \ / _` |/ _` |/ _ \
#  / ___ \| |_) | |_) | || | | | | | (_| | (_| |  __/
# /_/   \_\ .__/| .__/___|_| |_| |_|\__,_|\__, |\___|
#         |_|   |_|                       |___/
#  ___       _                       _
# |_ _|_ __ | |_ ___  __ _ _ __ __ _| |_ ___  _ __
#  | || '_ \| __/ _ \/ _` | '__/ _` | __/ _ \| '__|
#  | || | | | ||  __/ (_| | | | (_| | || (_) | |
# |___|_| |_|\__\___|\__, |_|  \__,_|\__\___/|_|
#                    |___/
#
# Author Andrianos Papamarkou
# Email: apapamarkou@yahoo.com
#
# This script is used to extract AppImages and create desktop entries for them.

set -euo pipefail

config_user="$HOME/.config/appimage-integrator/appimage-integrator.conf"
config_system="/etc/appimage-integrator/appimage-integrator.conf"

# Check if the config file exists
if [[ -f "$config_user" ]]; then
  source "$config_user"
elif [[ -f "$config_system" ]]; then
  source "$config_system"
else
  # Hard coded variables if no config found
  appimage_integrator_root="$HOME/.local/bin/appimage-integrator"
  watch_directory="$HOME/Applications"
fi

# Source logging functions
source "$appimage_integrator_root/logging.sh"
# Source notification functions
source "$appimage_integrator_root/notify.sh"
# Source translation functions
source "$appimage_integrator_root/messages.sh"

# Introduce Applications folder if not exist
mkdir -p "$watch_directory"

# Check if an argument was provided
if [ $# -ne 1 ]; then
    echo "$(get_translated "USAGE"): $0 <AppImage>"
    exit 1
fi

# Wait until the file is finished (if the action is copy or download)
wait_for_file_copy() {
    local file="$1"
    local previous_size=0
    local current_size=0
    local stable_count=0

    while true; do
        if [ -f "$file" ]; then
            current_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
            
            if [ "$current_size" = "$previous_size" ]; then
                stable_count=$((stable_count + 1))
                # If file size remains same for 3 checks (3 seconds), consider it complete
                if [ $stable_count -ge 3 ]; then
                    break
                fi
            else
                stable_count=0
            fi
            
            previous_size=$current_size
        fi
        sleep 1
    done
}
# Get the AppImage file path from the command line argument
appimage="$1"

# Wait for file to finish copying
log info "$(get_translated "WAITING_FOR_FILE")"
wait_for_file_copy "$appimage"

# Check if the file exists
if [ ! -f "$appimage" ]; then
    log err "$(get_translated "FILE_NOT_FOUND"): $appimage"
    exit 1
fi

# Get the AppImage name with the extension
appimage_full_name="${appimage##*/}"

# Get the AppImage name without the extension
appimage_name="${appimage_full_name%%.*}"

# Notify the desktop user that the script is running
notify "$(get_translated "APPIMAGE_INTEGRATOR")" "$(get_translated "SETTING_UP") $appimage_name"

# Create a unique temporary working directory in ~/tmp
workdir="$HOME/tmp/$appimage_name/"
mkdir -p "$workdir"

# Change to the working directory
cd "$workdir" || exit

# make appimage executable
chmod a+x "$appimage"

# Extract the AppImage
log info "$(get_translated "EXTRACTING") $appimage_name"
if ! "$appimage" --appimage-extract > /dev/null 2>&1; then
    log err "$(get_translated "EXTRACTION_FAILED")"
    exit 1
fi

# Define paths for extracted files
EXTRACTED_DIR="./squashfs-root"
log debug "$(get_translated "EXTRACTED_DIRECTORY"): $EXTRACTED_DIR"


# Check if the extraction directory exists
if [ ! -d "$EXTRACTED_DIR" ]; then
    log err "$(get_translated "EXTRACTION_DIR_NOT_FOUND"): $EXTRACTED_DIR"
    exit 1
fi

# Locate .desktop and icon files into extracted appimage
# replaced desktop_file=$(find "$EXTRACTED_DIR" -maxdepth 1 -name "*.desktop" | head -n 1)
# causing possible locale/globbing mismatch or shell quoting bug
for f in "$EXTRACTED_DIR"/*.desktop*; do
    [ -f "$f" ] && desktop_file="$f" && break
done
log debug "$(get_translated "desktop_file") $desktop_file"


# replaced icon_file=$(find "$EXTRACTED_DIR" -maxdepth 1 \( -name "*.png" -o -name "*.svg" \) | head -n 1)
# causing possible locale/globbing mismatch or shell quoting bug
for f in "$EXTRACTED_DIR"/*.png "$EXTRACTED_DIR"/*.svg; do
    [ -f "$f" ] && icon_file="$f" && break
done
icon_file_name="${icon_file##*/}"
log debug "$(get_translated "ICON_FILE") $icon_file"

# Check if .desktop file and icon file were found
if [ -z "$desktop_file" ]; then
    log err "$(get_translated "NO_desktop_file")"
    exit 1
fi

# Check if an icon file was found
if [ -z "$icon_file" ]; then
    log err "$(get_translated "NO_ICON_FILE")"
    exit 1
fi

# Define paths for extracted files
icon_path="$HOME/.local/share/icons"
updated_desktop_file="$HOME/.local/share/applications/$appimage_name.desktop"

# Ensure directories exist
mkdir -p "$icon_path" "$HOME/.local/share/applications"

# Copy files to their respective destinations
cp "$desktop_file" "$updated_desktop_file"
cp "$icon_file" "$icon_path/"

# Update the .desktop file with proper quoting for Exec field
sed -i "s|Exec=.*|Exec=\"${appimage}\"|g" "$updated_desktop_file"
sed -i "s|Icon=.*|Icon=${icon_path}/$icon_file_name|g" "$updated_desktop_file"

log debug "$(get_translated "CLEANUP")"
rm -rf "$workdir"

# Notify the desktop user that the script is done
notify "$(get_translated "appimage_INTEGRATOR")" "$appimage_name $(get_translated "READY_TO_USE")"
